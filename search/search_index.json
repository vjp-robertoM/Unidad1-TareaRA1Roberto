{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Unidad 1 \u2013 Tarea RA1 Prueba y validaci\u00f3n de una aplicaci\u00f3n Python (Lavadero) Contenido de la documentaci\u00f3n Objetivos de la actividad Resultados de aprendizaje y criterios de evaluaci\u00f3n Secciones de la documentaci\u00f3n Instrucciones de entrega Objetivos de la actividad El prop\u00f3sito de esta tarea es analizar, probar y validar una aplicaci\u00f3n desarrollada en Python , aplicando buenas pr\u00e1cticas de documentaci\u00f3n, depuraci\u00f3n y pruebas de software. En concreto, se trabajan los siguientes aspectos: An\u00e1lisis de la estructura interna del c\u00f3digo (clases, m\u00e9todos y flujo de control). Comprensi\u00f3n del modelo de ejecuci\u00f3n de la aplicaci\u00f3n y sus transiciones de estado. Uso de un IDE (Visual Studio Code) para la ejecuci\u00f3n y depuraci\u00f3n paso a paso. Dise\u00f1o e implementaci\u00f3n de pruebas unitarias para validar los requisitos funcionales. Detecci\u00f3n y correcci\u00f3n de errores l\u00f3gicos a partir de los resultados de los tests. Ejecuci\u00f3n de la aplicaci\u00f3n en un entorno controlado (Sandbox) . Reflexi\u00f3n sobre la infraestructura de seguridad de distintos lenguajes de programaci\u00f3n. Resultados de aprendizaje y criterios de evaluaci\u00f3n Esta actividad contribuye al Resultado de Aprendizaje RA1 , evaluando los siguientes criterios: a) An\u00e1lisis del c\u00f3digo fuente y su comportamiento. b) Uso de herramientas de desarrollo para ejecuci\u00f3n y depuraci\u00f3n. c) Dise\u00f1o y ejecuci\u00f3n de pruebas unitarias. d) Correcci\u00f3n de errores detectados mediante pruebas. e) Ejecuci\u00f3n controlada y reflexi\u00f3n sobre seguridad. Secciones de la documentaci\u00f3n Elementos de Python y documentaci\u00f3n del c\u00f3digo C\u00f3digo fuente de la aplicaci\u00f3n lavadero comentado, explicando el prop\u00f3sito de clases, m\u00e9todos y sentencias principales. Ejecuci\u00f3n y depuraci\u00f3n en el IDE Descripci\u00f3n de la ejecuci\u00f3n de la aplicaci\u00f3n en Visual Studio Code, errores detectados inicialmente y c\u00f3mo se solucionaron, con capturas de pantalla. Pruebas unitarias Explicaci\u00f3n de los tests realizados con Unittest/Pytest , relaci\u00f3n de cada test con los requisitos del enunciado, errores detectados y resultados de la ejecuci\u00f3n en modo verbose . Ejecuci\u00f3n en entorno controlado (Sandbox) Ejecuci\u00f3n de la aplicaci\u00f3n en un entorno aislado, descripci\u00f3n del proceso y capturas de pantalla que evidencian el aislamiento. Reflexi\u00f3n sobre seguridad en lenguajes de programaci\u00f3n Reflexi\u00f3n personal sobre las medidas de seguridad de distintos lenguajes de programaci\u00f3n y comparaci\u00f3n entre ellos. Instrucciones de entrega Para la correcta entrega de la actividad se ha realizado lo siguiente: Creaci\u00f3n del repositorio Unidad1-TareaRA1-Roberto en GitHub. Inclusi\u00f3n de la estructura completa de MkDocs , requirements.txt y GitHub Actions . Publicaci\u00f3n de la documentaci\u00f3n mediante GitHub Pages . Inclusi\u00f3n de las carpetas: src con el c\u00f3digo fuente corregido. tests con las pruebas unitarias realizadas. A\u00f1adido el profesor PPSvjp como colaborador en modo lectura. Finalmente, se entrega: El repositorio comprimido. El enlace a la p\u00e1gina de GitHub Pages donde se visualiza esta documentaci\u00f3n.","title":"Home"},{"location":"#unidad-1-tarea-ra1","text":"Prueba y validaci\u00f3n de una aplicaci\u00f3n Python (Lavadero)","title":"Unidad 1 \u2013 Tarea RA1"},{"location":"#contenido-de-la-documentacion","text":"Objetivos de la actividad Resultados de aprendizaje y criterios de evaluaci\u00f3n Secciones de la documentaci\u00f3n Instrucciones de entrega","title":"Contenido de la documentaci\u00f3n"},{"location":"#objetivos-de-la-actividad","text":"El prop\u00f3sito de esta tarea es analizar, probar y validar una aplicaci\u00f3n desarrollada en Python , aplicando buenas pr\u00e1cticas de documentaci\u00f3n, depuraci\u00f3n y pruebas de software. En concreto, se trabajan los siguientes aspectos: An\u00e1lisis de la estructura interna del c\u00f3digo (clases, m\u00e9todos y flujo de control). Comprensi\u00f3n del modelo de ejecuci\u00f3n de la aplicaci\u00f3n y sus transiciones de estado. Uso de un IDE (Visual Studio Code) para la ejecuci\u00f3n y depuraci\u00f3n paso a paso. Dise\u00f1o e implementaci\u00f3n de pruebas unitarias para validar los requisitos funcionales. Detecci\u00f3n y correcci\u00f3n de errores l\u00f3gicos a partir de los resultados de los tests. Ejecuci\u00f3n de la aplicaci\u00f3n en un entorno controlado (Sandbox) . Reflexi\u00f3n sobre la infraestructura de seguridad de distintos lenguajes de programaci\u00f3n.","title":"Objetivos de la actividad"},{"location":"#resultados-de-aprendizaje-y-criterios-de-evaluacion","text":"Esta actividad contribuye al Resultado de Aprendizaje RA1 , evaluando los siguientes criterios: a) An\u00e1lisis del c\u00f3digo fuente y su comportamiento. b) Uso de herramientas de desarrollo para ejecuci\u00f3n y depuraci\u00f3n. c) Dise\u00f1o y ejecuci\u00f3n de pruebas unitarias. d) Correcci\u00f3n de errores detectados mediante pruebas. e) Ejecuci\u00f3n controlada y reflexi\u00f3n sobre seguridad.","title":"Resultados de aprendizaje y criterios de evaluaci\u00f3n"},{"location":"#secciones-de-la-documentacion","text":"Elementos de Python y documentaci\u00f3n del c\u00f3digo C\u00f3digo fuente de la aplicaci\u00f3n lavadero comentado, explicando el prop\u00f3sito de clases, m\u00e9todos y sentencias principales. Ejecuci\u00f3n y depuraci\u00f3n en el IDE Descripci\u00f3n de la ejecuci\u00f3n de la aplicaci\u00f3n en Visual Studio Code, errores detectados inicialmente y c\u00f3mo se solucionaron, con capturas de pantalla. Pruebas unitarias Explicaci\u00f3n de los tests realizados con Unittest/Pytest , relaci\u00f3n de cada test con los requisitos del enunciado, errores detectados y resultados de la ejecuci\u00f3n en modo verbose . Ejecuci\u00f3n en entorno controlado (Sandbox) Ejecuci\u00f3n de la aplicaci\u00f3n en un entorno aislado, descripci\u00f3n del proceso y capturas de pantalla que evidencian el aislamiento. Reflexi\u00f3n sobre seguridad en lenguajes de programaci\u00f3n Reflexi\u00f3n personal sobre las medidas de seguridad de distintos lenguajes de programaci\u00f3n y comparaci\u00f3n entre ellos.","title":"Secciones de la documentaci\u00f3n"},{"location":"#instrucciones-de-entrega","text":"Para la correcta entrega de la actividad se ha realizado lo siguiente: Creaci\u00f3n del repositorio Unidad1-TareaRA1-Roberto en GitHub. Inclusi\u00f3n de la estructura completa de MkDocs , requirements.txt y GitHub Actions . Publicaci\u00f3n de la documentaci\u00f3n mediante GitHub Pages . Inclusi\u00f3n de las carpetas: src con el c\u00f3digo fuente corregido. tests con las pruebas unitarias realizadas. A\u00f1adido el profesor PPSvjp como colaborador en modo lectura. Finalmente, se entrega: El repositorio comprimido. El enlace a la p\u00e1gina de GitHub Pages donde se visualiza esta documentaci\u00f3n.","title":"Instrucciones de entrega"},{"location":"depuracion/","text":"Ejecuci\u00f3n y Depuraci\u00f3n En este apartado se documentan los problemas detectados durante la ejecuci\u00f3n y pruebas de la aplicaci\u00f3n Lavadero , as\u00ed como las soluciones aplicadas. 1. Error en la llamada a la simulaci\u00f3n del lavado Problema detectado: Al no indicar en el ejemplo 4 el par\u00e1metro encerado , Python lo tomaba por defecto como True , lo que provocaba errores posteriores en la l\u00f3gica de negocio. Soluci\u00f3n aplicada: Se a\u00f1adi\u00f3 expl\u00edcitamente el par\u00e1metro encerado=False para que la simulaci\u00f3n refleje correctamente las opciones deseadas: ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=False, encerado=False) 2. Regla de negocio del encerado Problema detectado: En Lavadero.hacerLavado exist\u00eda esta validaci\u00f3n: if not secado_a_mano and encerado: raise ValueError(\"No se puede encerar el coche sin secado a mano\") Si se solicitaba encerado sin secado a mano, el programa lanzaba un error y deten\u00eda la ejecuci\u00f3n. Soluci\u00f3n aplicada: Se modific\u00f3 para activar autom\u00e1ticamente el secado a mano cuando se solicita encerado: if encerado and not secado_a_mano: secado_a_mano = True print(\"AVISO: Se ha activado secado a mano autom\u00e1ticamente porque se solicit\u00f3 encerado.\") 3. Capturas de depuraci\u00f3n sin fallo","title":"Ejecuci\u00f3n y Depuraci\u00f3n"},{"location":"depuracion/#ejecucion-y-depuracion","text":"En este apartado se documentan los problemas detectados durante la ejecuci\u00f3n y pruebas de la aplicaci\u00f3n Lavadero , as\u00ed como las soluciones aplicadas.","title":"Ejecuci\u00f3n y Depuraci\u00f3n"},{"location":"depuracion/#1-error-en-la-llamada-a-la-simulacion-del-lavado","text":"Problema detectado: Al no indicar en el ejemplo 4 el par\u00e1metro encerado , Python lo tomaba por defecto como True , lo que provocaba errores posteriores en la l\u00f3gica de negocio. Soluci\u00f3n aplicada: Se a\u00f1adi\u00f3 expl\u00edcitamente el par\u00e1metro encerado=False para que la simulaci\u00f3n refleje correctamente las opciones deseadas: ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=False, encerado=False)","title":"1. Error en la llamada a la simulaci\u00f3n del lavado"},{"location":"depuracion/#2-regla-de-negocio-del-encerado","text":"Problema detectado: En Lavadero.hacerLavado exist\u00eda esta validaci\u00f3n: if not secado_a_mano and encerado: raise ValueError(\"No se puede encerar el coche sin secado a mano\") Si se solicitaba encerado sin secado a mano, el programa lanzaba un error y deten\u00eda la ejecuci\u00f3n. Soluci\u00f3n aplicada: Se modific\u00f3 para activar autom\u00e1ticamente el secado a mano cuando se solicita encerado: if encerado and not secado_a_mano: secado_a_mano = True print(\"AVISO: Se ha activado secado a mano autom\u00e1ticamente porque se solicit\u00f3 encerado.\")","title":"2. Regla de negocio del encerado"},{"location":"depuracion/#3-capturas-de-depuracion-sin-fallo","text":"","title":"3. Capturas de depuraci\u00f3n sin fallo"},{"location":"elementos_python/","text":"Enlace_Jupyter","title":"Elementos de Python"},{"location":"pruebas/","text":"Pruebas unitarias de la aplicaci\u00f3n Lavadero En este apartado se documenta el dise\u00f1o, implementaci\u00f3n y ejecuci\u00f3n de las pruebas unitarias realizadas sobre la aplicaci\u00f3n Lavadero , con el objetivo de verificar el correcto funcionamiento de los requisitos definidos en el enunciado de la actividad. Las pruebas se han implementado utilizando el m\u00f3dulo Unittest de Python. 1. Objetivo de las pruebas El objetivo principal de las pruebas unitarias es: Verificar el estado inicial del lavadero. Comprobar que se lanzan excepciones cuando se incumplen las reglas de negocio. Validar el c\u00e1lculo correcto de los ingresos seg\u00fan las opciones seleccionadas. Comprobar el flujo de fases del lavadero en todos los escenarios posibles. Detectar errores en la l\u00f3gica interna del programa para su posterior correcci\u00f3n. Cada test se corresponde directamente con una premisa del enunciado . 2. Preparaci\u00f3n del entorno de pruebas Las pruebas se encuentran en la carpeta tests del proyecto y utilizan la siguiente estructura: tests/ \u2514\u2500\u2500 test_lavadero_unittest.py 3. Fallos detectados y soluciones aplicadas M\u00e9todo incorrecto en la clase Lavadero Problema: Se llamaba al m\u00e9todo _hacer_lavado en lugar de hacerLavado . Soluci\u00f3n: Cambiar la llamada a self.lavadero.hacerLavado(...) . Test 3 Problema: Se lanzaba ValueError cuando deb\u00eda ser RuntimeError . Soluci\u00f3n: Sustituir la excepci\u00f3n por RuntimeError . Test 5 Problema: Los ingresos esperados eran 6 , pero el c\u00e1lculo correcto es 6.20 . Explicaci\u00f3n: El coste inicial de lavado es 5.00 y el coste adicional es 1.20 seg\u00fan el m\u00e9todo _cobrar . Soluci\u00f3n: Cambiar ingresos esperados de 6 a 6.20 . Test 7 Problema: Los ingresos esperados eran 7.50 . Explicaci\u00f3n: Con prelavado a mano ( 1.50 ) y secado a mano ( 1.20 ), el total correcto es 7.70 . Soluci\u00f3n: Cambiar ingresos esperados de 7.50 a 7.70 . Clase Lavadero \u2013 m\u00e9todo ejecutar_y_obtener_fases Problema: El m\u00e9todo estaba fuera de la clase por falta de tabulaci\u00f3n. Soluci\u00f3n: A\u00f1adir la indentaci\u00f3n correcta para que el m\u00e9todo quede dentro de la clase Lavadero . Test 9 Problema: fases_esperadas = [0, 1, 3, 4, 5, 6, 0] . Soluci\u00f3n: Cambiar a fases_esperadas = [0, 1, 3, 4, 5, 7, 0] . Test 10 Problema: fases_esperadas = [0, 1, 2, 3, 4, 5, 6, 0] . Soluci\u00f3n: Cambiar a fases_esperadas = [0, 1, 2, 3, 4, 5, 7, 0] . Test 11 Problema: fases_esperadas = [0, 1, 3, 4, 5, 7, 0] . Soluci\u00f3n: Cambiar a fases_esperadas = [0, 1, 3, 4, 5, 6, 0] . Test 12 Problema: fases_esperadas = [0, 1, 3, 4, 5, 7, 8, 0] . Soluci\u00f3n: Cambiar a fases_esperadas = [0, 1, 3, 4, 5, 6, 0] . Test 13 Problema: fases_esperadas = [0, 1, 2, 3, 4, 5, 7, 0] . Soluci\u00f3n: Cambiar a fases_esperadas = [0, 1, 2, 3, 4, 5, 6, 0] . Test 14 Problema: fases_esperadas = [0, 1, 2, 3, 4, 5, 7, 8, 0] . Soluci\u00f3n: Cambiar a fases_esperadas = [0, 1, 2, 3, 4, 5, 6, 0] . Test 15 Problema: Se llamaba a self.lavadero.hacerLavado(False, False, True) . Explicaci\u00f3n: No se puede encerar el coche sin haber realizado el secado a mano. Soluci\u00f3n: Cambiar a self.lavadero.hacerLavado(False, True, True) . 4. Ejecuci\u00f3n de test sin fallos","title":"Pruebas "},{"location":"pruebas/#pruebas-unitarias-de-la-aplicacion-lavadero","text":"En este apartado se documenta el dise\u00f1o, implementaci\u00f3n y ejecuci\u00f3n de las pruebas unitarias realizadas sobre la aplicaci\u00f3n Lavadero , con el objetivo de verificar el correcto funcionamiento de los requisitos definidos en el enunciado de la actividad. Las pruebas se han implementado utilizando el m\u00f3dulo Unittest de Python.","title":"Pruebas unitarias de la aplicaci\u00f3n Lavadero"},{"location":"pruebas/#1-objetivo-de-las-pruebas","text":"El objetivo principal de las pruebas unitarias es: Verificar el estado inicial del lavadero. Comprobar que se lanzan excepciones cuando se incumplen las reglas de negocio. Validar el c\u00e1lculo correcto de los ingresos seg\u00fan las opciones seleccionadas. Comprobar el flujo de fases del lavadero en todos los escenarios posibles. Detectar errores en la l\u00f3gica interna del programa para su posterior correcci\u00f3n. Cada test se corresponde directamente con una premisa del enunciado .","title":"1. Objetivo de las pruebas"},{"location":"pruebas/#2-preparacion-del-entorno-de-pruebas","text":"Las pruebas se encuentran en la carpeta tests del proyecto y utilizan la siguiente estructura: tests/ \u2514\u2500\u2500 test_lavadero_unittest.py","title":"2. Preparaci\u00f3n del entorno de pruebas"},{"location":"pruebas/#3-fallos-detectados-y-soluciones-aplicadas","text":"M\u00e9todo incorrecto en la clase Lavadero Problema: Se llamaba al m\u00e9todo _hacer_lavado en lugar de hacerLavado . Soluci\u00f3n: Cambiar la llamada a self.lavadero.hacerLavado(...) . Test 3 Problema: Se lanzaba ValueError cuando deb\u00eda ser RuntimeError . Soluci\u00f3n: Sustituir la excepci\u00f3n por RuntimeError . Test 5 Problema: Los ingresos esperados eran 6 , pero el c\u00e1lculo correcto es 6.20 . Explicaci\u00f3n: El coste inicial de lavado es 5.00 y el coste adicional es 1.20 seg\u00fan el m\u00e9todo _cobrar . Soluci\u00f3n: Cambiar ingresos esperados de 6 a 6.20 . Test 7 Problema: Los ingresos esperados eran 7.50 . Explicaci\u00f3n: Con prelavado a mano ( 1.50 ) y secado a mano ( 1.20 ), el total correcto es 7.70 . Soluci\u00f3n: Cambiar ingresos esperados de 7.50 a 7.70 . Clase Lavadero \u2013 m\u00e9todo ejecutar_y_obtener_fases Problema: El m\u00e9todo estaba fuera de la clase por falta de tabulaci\u00f3n. Soluci\u00f3n: A\u00f1adir la indentaci\u00f3n correcta para que el m\u00e9todo quede dentro de la clase Lavadero . Test 9 Problema: fases_esperadas = [0, 1, 3, 4, 5, 6, 0] . Soluci\u00f3n: Cambiar a fases_esperadas = [0, 1, 3, 4, 5, 7, 0] . Test 10 Problema: fases_esperadas = [0, 1, 2, 3, 4, 5, 6, 0] . Soluci\u00f3n: Cambiar a fases_esperadas = [0, 1, 2, 3, 4, 5, 7, 0] . Test 11 Problema: fases_esperadas = [0, 1, 3, 4, 5, 7, 0] . Soluci\u00f3n: Cambiar a fases_esperadas = [0, 1, 3, 4, 5, 6, 0] . Test 12 Problema: fases_esperadas = [0, 1, 3, 4, 5, 7, 8, 0] . Soluci\u00f3n: Cambiar a fases_esperadas = [0, 1, 3, 4, 5, 6, 0] . Test 13 Problema: fases_esperadas = [0, 1, 2, 3, 4, 5, 7, 0] . Soluci\u00f3n: Cambiar a fases_esperadas = [0, 1, 2, 3, 4, 5, 6, 0] . Test 14 Problema: fases_esperadas = [0, 1, 2, 3, 4, 5, 7, 8, 0] . Soluci\u00f3n: Cambiar a fases_esperadas = [0, 1, 2, 3, 4, 5, 6, 0] . Test 15 Problema: Se llamaba a self.lavadero.hacerLavado(False, False, True) . Explicaci\u00f3n: No se puede encerar el coche sin haber realizado el secado a mano. Soluci\u00f3n: Cambiar a self.lavadero.hacerLavado(False, True, True) .","title":"3. Fallos detectados y soluciones aplicadas"},{"location":"pruebas/#4-ejecucion-de-test-sin-fallos","text":"","title":"4. Ejecuci\u00f3n de test sin fallos"},{"location":"reflexion/","text":"Reflexi\u00f3n personal sobre las medidas de seguridad que incorporan los principales lenguajes de programaci\u00f3n La elecci\u00f3n del lenguaje de programaci\u00f3n es un factor crucial que influye directamente en la seguridad del software, tal como se\u00f1al\u00f3 Bruce Schneier: \"El lenguaje de programaci\u00f3n que elijas influir\u00e1 tanto en la seguridad de tu software como la cerradura que pones en tu puerta\". Esta analog\u00eda subraya que el dise\u00f1o fundamental del lenguaje puede ser la primera y m\u00e1s importante l\u00ednea de defensa contra vulnerabilidades. A partir de la clasificaci\u00f3n de los lenguajes de programaci\u00f3n (por nivel y por ejecuci\u00f3n) revisada en los contenidos te\u00f3ricos, se puede inferir c\u00f3mo la arquitectura de un lenguaje afecta inherentemente la seguridad: 1. Modelos de ejecuci\u00f3n y seguridad Los lenguajes suelen clasificarse en compilados , interpretados e h\u00edbridos (o basados en m\u00e1quina virtual). Esta distinci\u00f3n determina c\u00f3mo se transforma el c\u00f3digo fuente en instrucciones que ejecuta la computadora. 1.1 Lenguajes compilados Ejemplos: C, C++, Rust El proceso de compilaci\u00f3n traduce todo el c\u00f3digo fuente a c\u00f3digo m\u00e1quina antes de la ejecuci\u00f3n. Ventajas para la seguridad: Previene fallos de sintaxis antes de ejecutar el programa. Optimiza el c\u00f3digo para que se ejecute de manera eficiente. Riesgos: En lenguajes de bajo nivel como C o C++, la gesti\u00f3n manual de la memoria puede introducir vulnerabilidades cr\u00edticas, como buffer overflows . Notas adicionales: Lenguajes modernos como Rust han sido dise\u00f1ados para resolver problemas de seguridad en la gesti\u00f3n de memoria. 1.2 Lenguajes interpretados Ejemplos: Python, JavaScript, Ruby El c\u00f3digo se traduce l\u00ednea por l\u00ednea en tiempo de ejecuci\u00f3n mediante un int\u00e9rprete . Ventajas: Ciclo de desarrollo m\u00e1s r\u00e1pido. Mayor portabilidad si el int\u00e9rprete est\u00e1 disponible en el sistema. Riesgos: Posibles errores de sintaxis durante el desarrollo. Notas adicionales: La gesti\u00f3n autom\u00e1tica de memoria en estos lenguajes reduce algunos riesgos de seguridad. 1.3 Lenguajes h\u00edbridos / M\u00e1quina Virtual Ejemplos: Java, C# El c\u00f3digo fuente se compila primero a un bytecode , que luego es interpretado por una m\u00e1quina virtual (VM) . Ventajas para la seguridad: La VM act\u00faa como un entorno controlado, aislando el c\u00f3digo de fallos directos del sistema operativo. Aumenta la portabilidad entre plataformas. Riesgos: Peque\u00f1a sobrecarga de rendimiento en comparaci\u00f3n con c\u00f3digo compilado a m\u00e1quina. 2. Paradigmas de programaci\u00f3n y seguridad Los paradigmas tambi\u00e9n influyen en la seguridad a trav\u00e9s de la estructuraci\u00f3n del c\u00f3digo. 2.1 Programaci\u00f3n Orientada a Objetos (POO) La POO define conceptos como clase y objeto , buscando maximizar la cohesi\u00f3n y minimizar el acoplamiento. Encapsulaci\u00f3n: Oculta el c\u00f3digo interno de las clases, limitando el acceso directo a los datos internos. Ventajas para la seguridad: Previene manipulaciones inesperadas del estado. Reduce la probabilidad de errores que puedan derivar en vulnerabilidades. 3. Conclusi\u00f3n personal La seguridad no solo depende de las bibliotecas o herramientas (como depuradores en un IDE), sino tambi\u00e9n de la elecci\u00f3n del lenguaje y sus caracter\u00edsticas fundamentales. Lenguajes modernos que emplean m\u00e1quinas virtuales aportan una capa de seguridad y portabilidad superior al abstraer la gesti\u00f3n de recursos cr\u00edticos. Lenguajes de bajo nivel transfieren mayor responsabilidad de la seguridad al programador. En \u00faltima instancia, la \"cerradura\" (el lenguaje) es tan importante como las buenas pr\u00e1cticas del desarrollador.","title":"Reflexi\u00f3n"},{"location":"reflexion/#reflexion-personal-sobre-las-medidas-de-seguridad-que-incorporan-los-principales-lenguajes-de-programacion","text":"La elecci\u00f3n del lenguaje de programaci\u00f3n es un factor crucial que influye directamente en la seguridad del software, tal como se\u00f1al\u00f3 Bruce Schneier: \"El lenguaje de programaci\u00f3n que elijas influir\u00e1 tanto en la seguridad de tu software como la cerradura que pones en tu puerta\". Esta analog\u00eda subraya que el dise\u00f1o fundamental del lenguaje puede ser la primera y m\u00e1s importante l\u00ednea de defensa contra vulnerabilidades. A partir de la clasificaci\u00f3n de los lenguajes de programaci\u00f3n (por nivel y por ejecuci\u00f3n) revisada en los contenidos te\u00f3ricos, se puede inferir c\u00f3mo la arquitectura de un lenguaje afecta inherentemente la seguridad:","title":"Reflexi\u00f3n personal sobre las medidas de seguridad que incorporan los principales lenguajes de programaci\u00f3n"},{"location":"reflexion/#1-modelos-de-ejecucion-y-seguridad","text":"Los lenguajes suelen clasificarse en compilados , interpretados e h\u00edbridos (o basados en m\u00e1quina virtual). Esta distinci\u00f3n determina c\u00f3mo se transforma el c\u00f3digo fuente en instrucciones que ejecuta la computadora.","title":"1. Modelos de ejecuci\u00f3n y seguridad"},{"location":"reflexion/#11-lenguajes-compilados","text":"Ejemplos: C, C++, Rust El proceso de compilaci\u00f3n traduce todo el c\u00f3digo fuente a c\u00f3digo m\u00e1quina antes de la ejecuci\u00f3n. Ventajas para la seguridad: Previene fallos de sintaxis antes de ejecutar el programa. Optimiza el c\u00f3digo para que se ejecute de manera eficiente. Riesgos: En lenguajes de bajo nivel como C o C++, la gesti\u00f3n manual de la memoria puede introducir vulnerabilidades cr\u00edticas, como buffer overflows . Notas adicionales: Lenguajes modernos como Rust han sido dise\u00f1ados para resolver problemas de seguridad en la gesti\u00f3n de memoria.","title":"1.1 Lenguajes compilados"},{"location":"reflexion/#12-lenguajes-interpretados","text":"Ejemplos: Python, JavaScript, Ruby El c\u00f3digo se traduce l\u00ednea por l\u00ednea en tiempo de ejecuci\u00f3n mediante un int\u00e9rprete . Ventajas: Ciclo de desarrollo m\u00e1s r\u00e1pido. Mayor portabilidad si el int\u00e9rprete est\u00e1 disponible en el sistema. Riesgos: Posibles errores de sintaxis durante el desarrollo. Notas adicionales: La gesti\u00f3n autom\u00e1tica de memoria en estos lenguajes reduce algunos riesgos de seguridad.","title":"1.2 Lenguajes interpretados"},{"location":"reflexion/#13-lenguajes-hibridos-maquina-virtual","text":"Ejemplos: Java, C# El c\u00f3digo fuente se compila primero a un bytecode , que luego es interpretado por una m\u00e1quina virtual (VM) . Ventajas para la seguridad: La VM act\u00faa como un entorno controlado, aislando el c\u00f3digo de fallos directos del sistema operativo. Aumenta la portabilidad entre plataformas. Riesgos: Peque\u00f1a sobrecarga de rendimiento en comparaci\u00f3n con c\u00f3digo compilado a m\u00e1quina.","title":"1.3 Lenguajes h\u00edbridos / M\u00e1quina Virtual"},{"location":"reflexion/#2-paradigmas-de-programacion-y-seguridad","text":"Los paradigmas tambi\u00e9n influyen en la seguridad a trav\u00e9s de la estructuraci\u00f3n del c\u00f3digo.","title":"2. Paradigmas de programaci\u00f3n y seguridad"},{"location":"reflexion/#21-programacion-orientada-a-objetos-poo","text":"La POO define conceptos como clase y objeto , buscando maximizar la cohesi\u00f3n y minimizar el acoplamiento. Encapsulaci\u00f3n: Oculta el c\u00f3digo interno de las clases, limitando el acceso directo a los datos internos. Ventajas para la seguridad: Previene manipulaciones inesperadas del estado. Reduce la probabilidad de errores que puedan derivar en vulnerabilidades.","title":"2.1 Programaci\u00f3n Orientada a Objetos (POO)"},{"location":"reflexion/#3-conclusion-personal","text":"La seguridad no solo depende de las bibliotecas o herramientas (como depuradores en un IDE), sino tambi\u00e9n de la elecci\u00f3n del lenguaje y sus caracter\u00edsticas fundamentales. Lenguajes modernos que emplean m\u00e1quinas virtuales aportan una capa de seguridad y portabilidad superior al abstraer la gesti\u00f3n de recursos cr\u00edticos. Lenguajes de bajo nivel transfieren mayor responsabilidad de la seguridad al programador. En \u00faltima instancia, la \"cerradura\" (el lenguaje) es tan importante como las buenas pr\u00e1cticas del desarrollador.","title":"3. Conclusi\u00f3n personal"},{"location":"sandbox/","text":"Prueba de aplicaciones en un entorno de ejecuci\u00f3n controlado (Sandboxing) En este apartado se describe c\u00f3mo se cre\u00f3 un entorno de ejecuci\u00f3n aislado para probar la aplicaci\u00f3n lavadero.py utilizando Firejail y su interfaz gr\u00e1fica Firetools . 1. Preparaci\u00f3n del entorno sandbox Para garantizar la seguridad y el aislamiento del sistema, se siguieron los siguientes pasos: 1.1 Instalaci\u00f3n de Firejail y Firetools sudo apt update sudo apt install firejail -y sudo apt install firetools -y 1.2 Crear un entorno virtual de Python python3 -m venv .venv # Crear entorno virtual source .venv/bin/activate # Activar entorno virtual # Instalaci\u00f3n de dependencias para lavadero.py pip install -r requeriments.txt pip install -e . 1.3 Ejecutar la aplicaci\u00f3n en sandbox Para aislar la ejecuci\u00f3n de la aplicaci\u00f3n: firejail --private=.venv python3 src/lavadero.py 1.4 Ejecuci\u00f3n de pruebas unitarias PYTHONPATH=src python3 -m unittest tests/test_lavadero_unittest.py -v Al ser la primera prueba, me salen todos los fallos de la aplicaci\u00f3n","title":"Ejecuci\u00f3n en Sandbox"},{"location":"sandbox/#prueba-de-aplicaciones-en-un-entorno-de-ejecucion-controlado-sandboxing","text":"En este apartado se describe c\u00f3mo se cre\u00f3 un entorno de ejecuci\u00f3n aislado para probar la aplicaci\u00f3n lavadero.py utilizando Firejail y su interfaz gr\u00e1fica Firetools .","title":"Prueba de aplicaciones en un entorno de ejecuci\u00f3n controlado (Sandboxing)"},{"location":"sandbox/#1-preparacion-del-entorno-sandbox","text":"Para garantizar la seguridad y el aislamiento del sistema, se siguieron los siguientes pasos:","title":"1. Preparaci\u00f3n del entorno sandbox"},{"location":"sandbox/#11-instalacion-de-firejail-y-firetools","text":"sudo apt update sudo apt install firejail -y sudo apt install firetools -y","title":"1.1 Instalaci\u00f3n de Firejail y Firetools"},{"location":"sandbox/#12-crear-un-entorno-virtual-de-python","text":"python3 -m venv .venv # Crear entorno virtual source .venv/bin/activate # Activar entorno virtual # Instalaci\u00f3n de dependencias para lavadero.py pip install -r requeriments.txt pip install -e .","title":"1.2 Crear un entorno virtual de Python"},{"location":"sandbox/#13-ejecutar-la-aplicacion-en-sandbox","text":"Para aislar la ejecuci\u00f3n de la aplicaci\u00f3n: firejail --private=.venv python3 src/lavadero.py","title":"1.3 Ejecutar la aplicaci\u00f3n en sandbox"},{"location":"sandbox/#14-ejecucion-de-pruebas-unitarias","text":"PYTHONPATH=src python3 -m unittest tests/test_lavadero_unittest.py -v Al ser la primera prueba, me salen todos los fallos de la aplicaci\u00f3n","title":"1.4 Ejecuci\u00f3n de pruebas unitarias"}]}